Processon思维导图链接地址：https://www.processon.com/mindmap/61643651e401fd3c24907e83
---------------------------------------------------------------------------------------------------------------------------------------------------------------
【Spring01-IOC】
    【demo1_introduction】
         【控制就是获得实例的过程】UserService、UserServiceImpl、
             以前我们通过new来获取一个实例对象，现在可以使用Spring容器来获取实例对象。
             注意Junit的使用。pom.xml中scope范围对应test。 //@Test注解
    【demo2_ioc1】
         【准备】
             【导包spring-context】
                 spring-context包括spring-expression、spring-core（包括spring-jcl）、spring-aop、spring-beans
                 Maven中的小板凳标志可以可视化的看到包之间的依赖关系。
                 IDEA默认的Maven不是阿里的，外网下载比较慢，可以在setting->Maven中查看更改Maven的路径、版本、配置、仓库。
             【业务代码】UserService、UserServiceImpl
             【Spring官网配置文件】
                 链接地址：https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#xsd-schemas-context
                 可以复制该内容，并编辑一个文件模板，以备后用。
             【resource中创建application.xml】
                 使用刚刚生成的文件模板。
             【使用反射获取实例对象】IOCTest.test1()
                 Spring就是基于反射获取类的实例的。
                 Class.forName()、aClass.newInstance()
         【使用Spring】
             【在application.xml中注册组件】
                 <com.bean>标签、id属性、class属性
             【方式1---组件id】IOCTest.test2()
                 spring容器提供了应用上下文applicationContext，通过应用上下文可以获得组件。
                     需要加载spring配置文件 -> 直接写resources（classpath）下的配置文件名。
                     new ClassPathXmlApplicationContext("application.xml");
                 获取实例对象：applicationContext.getBean("userService")  //getBean()中的字符串参数是，要获取的对象所属的组件的id。
             【方式2---类的类型class】IOCTest.test3()
                 加载应用上下文同方式1。
                 获取实例对象：applicationContext.getBean(UserServiceImpl.class); //通过要加载的类的类型来获取实例对象。
             【方式1和方式2的比较】
                 同一个类型的组件不唯一（也就是在application.xml中用不同的id注册了两次），则方式1不会报异常，而方式2会报异常。
    【demo3_ioc2】
         【业务代码】User、UserDao、UserDaoImpl、UserService、UserServiceImpl
              //lombok的使用
              //application.xml中，bean标签的property子标签的name属性和ref属性。
                注意，这里name属性的值和bean标签对应的类的set方法的方法名是必须对应的，
                比如说，UserService中包含成员变量UserDao，
                      如果UserService中的set方法名是setUserDaoz()，则spring配置文件中UserService对应的bean标签的子标签（对应UserDao）的name值应该是userDaoz。
                      如果UserService采用了@Data注解（默认为setUserDao()），则name值应该为userDao。
         【使用se的形式】IOCTest.test1()
         【使用spring的形式】IOCTest.test2()【这块有点乱】
         【比较】
             [1]直接通过spring容器获取UserDao；
             [2]先通过spring容器获取UserService，在通过UserService的getUserDao()获取UserDao；
             [3] [1][2]两种方式获取到的UserDao是同一个。
         【ClassPathXmlApplicationContext和FileSystemXmlApplicationContext】ApplicationContextTest
             [1]ClassPathXmlApplicationContext
                   classpath：resources（或java）下的文件名
                   new ClassPathXmlApplicationContext("application.xml")
             [2]FileSystemXmlApplicationContext
                   文件系统：文件的全名
                   new FileSystemXmlApplicationContext(configPath);//configPath是application.xml的绝对路径。
             [3]ClassPathXmlApplicationContext和FileSystemXmlApplicationContext的比较
                   两者获取到的bean不是同一个，因为上下文就不是同一个。
             //Ctr+H查找键，向上查找、向下查找。
    【demo4_scope】
         【bean的作用域】
             //默认情况下：true          //获得的是同一个bean
             //scope=singleton  true   //获得的是同一个bean
             //scope=prototype  false  //获得的不是同一个bean
         【singleton，但是上下文不同】
             获取的不是同一个bean，因为spring容器上下文不同。
    【demo5_regist】NoArgsConstructorBean、AllArgsConstructorBean、application.xml、registTest
         【组件注册---无参构造】
             <com.bean>标签的子标签<property>的name属性（和bean的成员变量一致）、value属性（注意和ref属性的区别）
         【组件注册---有参构造】
             <com.bean>标签的子标签<constructor-arg>的name属性（和有参构造方法的参数一致，而非和成员变量一致）、value属性。
             重要：name属性的值和有参构造方法的参数一致，而非和成员变量一致。
                  采用lombok的@AllArgsConstructor注解，则显然和成员变量一致，
                  否则，一定要注意有参构造函数的形参名！（如示例中的usernameA和passwordA）
         //lombok的@NoArgsConstructor注解、@AllArgsConstructor注解
    【demo6_factory】
          //静态工厂：在静态工厂类的静态方法中return一个新创建的bean对象。
            实例工厂：在实例工厂类的非静态方法中return一个新创建的bean对象。
         【se的形式】
             //静态工厂：不需要实例化静态工厂，就可以创建一个bean对象。
               实例工厂：需要实例化实例工厂，才可以用实例工厂对象创建一个bean对象。
         【Spring的形式】
             //主要关注spring的配置文件application.xml的区别
             //静态工厂：
                 [1]直接获取bean对象
                    bean标签（bean对象）：id、class（指向静态工厂）、factory-method（静态工厂中创建bean对象的静态方法的方法名）
             //实例工厂：
                 [1]实例工厂要先实例化
                    bean标签（实例工厂对象）：id、class（指向实例工厂）
                 [2]然后在通过实例工厂的实例对象来获取bean对象
                    bean标签（bean对象）：id、factory-bean（实例工厂对象的id）、factory-method（实例工厂中创建bean对象的非静态方法的方法名）
    【demo7_lifecycle】
         【疑问】这一块还是比较迷
         //bean标签中的init-method属性、destroy-method属性。
---------------------------------------------------------------------------------------------------------------------------------------------------------------
【Spring02-AOP】
    【demo1-collection】
         //创建一个集合Bean，在类中创建各种集合类型的成员变量。  //CollectionBean
         //成员变量的类型有array、list、set、map、properties
         //包含这些类型的成员变量的bean怎么在spring配置文件中进行注册，是这个模块要解决的问题。
         【起步】
             首先，bean对象的成员变量在组件注册时，都需要一个<property>子标签。<property>标签的name属性值为成员变量名。
         【Array】
             <property> -> <array> -> <value> //<value>标签中写具体的值。
         【List】
             <property> -> <list> -> <value> //<value>标签中写具体的值。
         【Set】
             <property> -> <set> -> <value> //<value>标签中写具体的值。
         【Map】
             <property> -> <map> -> <entry> //<entry>标签的key属性、value属性中写入具体的key、value值。
         【Properties】
             <property> -> <props> -> <prop> //<prop>标签的key属性写入具体的key值，<prop>标签中写入具体的value值。
             //注意区分Map和Properties的value值写入的位置。
         【bean对象的成员变量是集合类型，并且集合的元素类型不是基本类型的包装类】
             //这里举一个User类的例子
             【起步】<property> -> <array>、<list>、<set>、<map>这部分都是一样的。
                   和之前不同的是值不再是简单的写在<value>标签中，因为现在的值是bean对象，要按照<bean>注册的形式写。
                   bean对象有国产和进口两种方式。
                   <array>、<list>、<set>最简单。
                      国产：<bean>标签&class属性（id属性不需要） -> <property>子标签&name属性&value属性。
                      进口：<ref>标签&bean属性（指向要引用的已经注册的bean的id）。
                   <map>稍有不同。
                      国产：<entry>标签&key属性 -> <bean>标签&class属性（id属性不需要） -> <property>子标签&name属性&value属性。
                      进口1：<entry>标签&key属性&value-ref属性（指向要引用的已经注册的bean的id）
                      进口2：<entry>标签&key属性 -> <ref>子标签&&bean属性（指向要引用的已经注册的bean的id）。
    【demo2-annotation】
          //spring配置文件中，<context:component-scan base-package="com.bupt"/>
            <context:component-scan>标签：打开注解扫描开关。
                base-package属性：扫描base-package属性值对应的包及其全部子包。
         【之前的方式】
             组件注册都是在application.xml中注册的。
             //在application.xml中注册 userService -> UserServiceImpl
         【注解】
              【@Component注解】
                  此时注释掉配置文件中userService的注册。UserServiceImpl类上加上@Component注解。
                  测试出错：原因UserServiceImpl类加上@Component注解，默认是以userServiceImpl为组件id的。//以类名首字母小写作为组件id。
                  解决：@Component("userService") //@Component注解带id参数，指定注册的组件的id。
              【组件注册相关】
                  //@Repository、@Service、@Controller注解
                  //特定的类上去使用的组件注册注解。
                    @Repository -> dao的实现类
                    @Service -> service的实现类
                    @Controller -> SpringMVC控制层的类上（后面会使用到）
                  //不带id参数的@Service注解和不带id参数的@Component注解效果相同。
                  【疑问】如果UserServiceImpl加上不带id参数的@Service注解，
                            并以getBean("userService")的形式获取bean，则会报错。//@Service注解需要指定id为userService
                            而以getBean(UserService.class)的形式获取bean，则运行正常。
              【组件注入相关】
                  【@Autowired】
                      //UserServiceImpl类中添加了UserDao成员变量。
                        使用XML配置注册userService时，需要一个<property>子标签，id值为userDao，并且需要UserServiceImpl类提供对应的set方法（可以直接用@Data注解）。
                        此时，我们使用@Service注解，会报空指针异常，因为此时的userDao为null。
                      //这个时候我们全部采用注解的方式。
                        UserServiceImpl -> @Service、UserDaoImpl -> @Repository
                        然后，最关键的，在UserServiceImpl类的成员变量userDao前面加上@Autowired注解，注入容器中已经注册的UserDaoImpl。
                        也就是说：采用注解注入的方式甚至不需要提供set方法。
                  【@Qualifier】
                      //如果容器中这个类型的组件只有一个，则可以直接使用@Autowired
                        如果容器中这个类型的组件不止一个，则需要加上@Qualifier，并指定组件的id。//@Qualifier必须搭配@Autowired使用。
                  【@Resource】
                      //只写@Resource相当于@Autowired，如果这个类型的组件不止一个，则需要使用name属性指定id。
                  【三者总结】
                      @Autowired -> 不能指定组件的id，只适用于同类型的组件只有一个的情况。
                      @Qualifier -> 搭配@Autowired使用，可以指定组件的id，解决了@Autowired不适用于同类型的组件只有一个的情况的问题。
                      @Resource -> 可以不指定组件的id，也可以指定组件的id。//和@Qualifier不同，它不需要和@Autowired搭配使用。
                  【@Value】
                      //给值属性的成员变量注入值。
                      //比如userDao、userInfo、maxSize都是UserServiceImpl类的成员变量，
                        userDao需要作为组件注入，而userInfo、maxSize只是普通的变量，而在这些变量前加上@Value注解，可以给这些变量注入值。
                        例如，@Value("czgbyer666")、@Value("10")
                      //@Value还可以从properties中取key和value。
                        首先，需要在application.xml中加载这个properties文件。
                        <context:property-placeholder location="classpath:user.properties"/>
                        然后可以直接使用@Value("${user.userInfo}")、@Value("${user.maxSize}")加载key-value。
                      //引进的properties配置文件的值除了在@Value中使用，在spring配置文件中也可以使用。//让bean标签的value值为${}。
              【作用域相关】
                  【@Scope】
                       @Scope -> 默认单例
                       @Scope("singleton") -> 单例
                       @Scope("prototype") -> 原型
              【生命周期】
                  【spring配置文件的形式】
                      <bean>标签的 id属性 & class属性 & init-method属性 & destroy-method属性。
                      init-method属性 和 destroy-method属性 的值指定为自定义的init、destroy方法。
                  【注解的形式】
                      //@PostConstruct、@PreDestroy
                      注释掉<bean>标签的内容，LifeCycleBean的前面加上@Component注解。此时init、destroy方法失效。
                      在自定义的init、destroy方法上分别加上@PostConstruct、@PreDestroy注解，则init、destroy方法再次生效。
                  【单元测试类】【有点迷】
                      pom.xml中加入spring-test包。
                      在测试类中，如果直接注入UserService组件，并调用其sayHi方法，会报空指针异常。
                      要先在测试类上加上@RunWith(SpringJUnit4ClassRunner.class)、@ContextConfiguration("classpath:application.xml")，才能生效。【有点迷】
    【demo3-dynamic_proxy】
         //AOP---手动实现
         【AOP基础概念】
             AOP：面向切面编程。 //把需要增强的方法放到一起，做一个统一的调用。
             target（目标类）-> proxy（代理类）
             joinpoint（连接点）：过程中的某个点
             pointcut（切入点）：划分增强范围，指定哪些方法被增强。//谁（哪个方法）
             advice（通知）：在什么时间，做什么事情。
             weaver（织入）：动作，由目标类对象生成代理类对象的动作。
             Aspect（切面）：切面=切入点+通知 //谁，在什么时间，做什么事情
         【AOP的底层】
             采用动态代理增强。
             如果有接口的实现，采用jdk动态代理。
             如果没有接口的实现，采用cglib动态代理。
         【AOP实战---手动采用动态代理---jdk动态代理】
             [1]创建target对象userService
             [2]创建proxy对象userServiceProxy
                 Proxy.newInstance()
                     //包含3个参数：
                         1.userService.getClass().getClassLoader()
                         2.userService.getClass().getInterfaces()
                         3.new InvocationHandler()
                             //这是创建一个匿名内部类对象
                             //主要逻辑在于重写匿名内部类InvocationHandler的invoke方法
                                 //invoke方法的3个参数：Object proxy, Method method, Object[] args
                                   Object invoke = method.invoke(userService, args);
                                   在这条赋值语句的前后写增强的语句。
                                   return invoke
             [3]proxy对象userServiceProxy调用原来的方法（已经被增强）。
         【AOP实战---手动采用动态代理---cglib动态代理】
             【注意】
                 //使用cglib动态代理需要导spring-context包。
             [1]创建target对象userService
             [2]创建proxy对象userServiceProxy
                 Enhancer.create()
                     //包含2个参数：
                         1.UserService.class
                         2.new InvocationHandler()
                             //这是创建一个匿名内部类对象  //查看源码可以发现这里的InvocationHandler接口和jdk动态代理里面的不是同一个。
                             //主要逻辑在于重写匿名内部类InvocationHandler的invoke方法
                                 //invoke方法的3个参数：Object o, Method method, Object[] objects
                                 Object invoke = method.invoke(userService, objects);
                                 在这条赋值语句的前后写增强的语句。
                                 return invoke
             [3]proxy对象userServiceProxy调用原来的方法（已经被增强）。
    【demo4-spring_aop】
         //AOP---采用spring aop的形式实现
         【业务代码】UserService、UserServiceImpl
         //首先，打开注解扫描开关，<context:component-scan>标签。
         【自定义advice通知】CustomAdvice
             //加上@Component注解
             实现MethodInterceptor接口。//方法拦截器
                 重写invoke()方法：
                     方法参数：MethodInvocation methodInvocation
                     Object proceed = methodInvocation.proceed();
                     在这条赋值语句的前后写增强的语句。
                     return proceed;
         【注册一个代理对象组件】【有点迷惑】application.xml
             //id属性值为：userServiceProxy
             //class属性值为：org.springframework.aop.framework.ProxyFactoryBean
             //userServiceProxy有两个成员：
                 [1]target//目标类
                     ref属性值为：userServiceImpl
                 [2]interceptorNames//拦截器名字，即，通过哪个advice增强的。
                     value值为customAdvice  //这个参数是字符串类型，写的是value属性，而非ref属性。
         【测试】SpringAOPTest
             //pom.xml中要导入spring-test包。
               要先在测试类上加上@RunWith(SpringJUnit4ClassRunner.class)、@ContextConfiguration("classpath:application.xml")，才能生效。【疑问】
             //[1]@Autowired  //直接注入UserService组件，并调用其sayHi方法，会报空指针异常。
             //[2]@Resource(name = "userServiceImpl")  //AOP未生效
             //[3]@Resource(name = "userServiceProxy") //AOP生效
    【demo5-advisor】
        //demo4-spring_aop中的代理对象是在application.xml中手动注册生成的，目前只有一个代理对象。
          如果需要100个代理对象呢？手动生成会非常麻烦。
        【准备工作】
             [1]pom.xml中导入aspectjweaver这个包
             [2]application.xml中在Spring官网配置文件01的基础上，引入aop的schema。
                  <beans>标签中增加xmlns:aop属性，其属性值为http://www.springframework.org/schema/aop
                  <beans>标签的xsi:schemaLocation属性值中，加入http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd
        【Pointcut切入点表达式】
             作用：划分方法（直接指定某一些方法）
             表达式：execution(修饰符，返回值，包名.类名.方法名(参数))
                 修饰符：可以省略，省略代表任意的修饰符。
                 返回值：不可以省略，可以使用*来进行通配。
                     //返回值的写法：如果是基本类型或者是java.lang包目录下的，可以直接写。
                                   如果不在这个范围，需要写全类名。
                 包名.类名.方法名：首尾不能省略，中间部分可以省略，使用..进行省略。
                                 可以使用*通配，*可以代表一个单词或者一个单词的一部分。
                 参数：可以省略不写，省略不写代表的是无参函数。
                      *通配一个参数，..代表任意参数（任意数量任意类型的参数）。
                      和返回值相同，如果是基本类型或者是java.lang包目录下的，可以直接写。
                                  如果不在这个范围，需要写全类名。
        【业务代码】User、UserService、UserServiceImpl
                  CustomAdvice //实现MethodInterceptor接口 //@Component
                  AdvisorTest
             //此处AdvisorTest使用@Autowired注解注入UserService对象不会报空指针异常【有点迷惑，同上】
        【application.xml的配置】
             <aop:config>标签 -> <aop:advisor>子标签 -> advice-ref属性 & pointcut属性
             advice-ref属性的值是advice组件的id。
             pointcut属性值为切入点表达式。
                 demo5的例子：
                     完整的切入点表达式：execution(public void com.bupt.service.UserServiceImpl.sayHello(String))
                     修饰符省略，返回值通配，包名.类名.方法名部分省略首尾通配，参数不省略：execution(* *.bu*..*(String))
                         //注意：这里参数不要省略，省略就代表无参了，aop会不生效
---------------------------------------------------------------------------------------------------------------------------------------------------------------
【Spring03-Aspect】
    【demo1-aspectj】
        【导包】spring-context、spring-test、junit、lombok、aspectjweaver
        【业务代码】UserService、UserServiceImpl
        【定义切面类】CustomAspect
            //@Component
            //切面类中的方法（通知方法）：就是做什么事情。//mybefore()、myafter()
              时间：由我们来决定。 //在application.xml中将切面类的方法和aop的before、after等关联起来。
        【application.xml中进一步配置】
            <aop:config>标签
                -> <aop:aspect>标签
                        //ref属性（指向自定义的切面类的id）
                    -> <aop:pointcut>标签
                        //id属性 & expression属性
                    -> <aop:before>标签
                        //method属性（自定义切面类中对应的方法名）
                        //pointcut-ref属性（指向pointcut的id）
                    -> <aop:after>标签
                    -> <aop:after-throwing>标签
                    -> <aop:after-returning>标签
                    -> <aop:around>标签
        【测试】AspectjTest
            此时测试类中的UserService对象已经是一个代理对象了。
        【在通知方法中可以增加JoinPoint类的形参】
            Signature getSignature();  //获取封装了方法签名的对象，通过Signature可以进一步获取方法名等信息。
            Object[] args;  //获取传入目标方法的参数对象
            Object getTarget();  //获取被代理对象
            Object getThis();  //获取代理对象
        【doAround】
            <aop:around>标签
            CustomAdvice中的myaround()方法。
                增加一个ProceedingJoinPoint类的形参。还包括一个Object类型的返回值。
                之后的操作类似手动代理中的方法增强：
                    Object proceed = proceedingJoinPoint.proceed();
                    在这条赋值语句的前后写增强的语句。
                    return proceed;
        【after-returning】
            <aop:after-returning>标签  //注意多了一个returning属性，属性值为”object”。
            CustomAdvice中的myafterReturning()方法。
                增加一个Object类型的形参。
                可以在方法中输出object。//如果切入点方法没有返回值，则object的值为null；
                                       如果切入点方法有返回值，则object的值为这个返回值的值。
        【after-throwing】
            <aop:after-throwing>标签  //注意多了一个throwing属性，属性值为”throwable”。
            CustomAdvice中的myafterThrowing()方法。
                增加了一个Throwable类型的形参。
                可以在方法中输出throwable。//如果切入点方法没有抛出异常，则throwable的值为null；
                                          如果切入点方法有抛出异常，则throwable的值为这个异常的异常信息。//例如，除零异常：java.lang.ArithmeticException: / by zero
        【补充&总结】
            通知方法均可以增加JoinPoint形参。
            around的返回值是Object，形参是ProceedingJoinPoint。
            after-returning、after-throwing都有特殊类型的形参。
            <aop:pointcut>标签可以写在<aop:aspect>标签里面，也可以写在外面。
    【demo2-aspect_annotation】
        //通过注解来使用aspectj，不再使用<aop:config>标签。
        【准备】复制deno1种的业务代码、切面类、测试类、pom.xml
        【注解方式】
            [1]application.xml中增加<aop:aspectj-autoproxy>标签，打开注解开关。
            [2]切面类上增加@Aspect注解，标记为切面类。
               //这样就不需要在配置文件中使用<aop:aspect>来注册切面类了。
               //注意：@Component和@Aspect注解缺一不可。
            [3]在通知方法上增加对应的注解。  //这样就不需要在配置文件中使用对应的通知方法、pointcut的标签。
               //第一种方式（在通知方法注解中，直接写入切入点表达式）：
                     @Before("execution(...)")
                     @After("execution(...)")
                     @Around("execution(...)")
                     @AfterReturning(value="execution(...)",returning="object")
                     @AfterThrowing(value="execution(...)",throwing="throwable")
               //第二种方式（先注册切入点表达式组件，再在通知方法中引用切入点表达式）
                     @Pointcut("execution(...)")
                     public void mypointcut(){}
                     @Before("mypointcut()")
                     @After("mypointcut()")
                     @Around("mypointcut()")
                     @AfterReturning(value="mypointcut()",returning="object")
                     @AfterThrowing(value="mypointcut()",throwing="throwable")
    【demo3-aspectj_annotation】
         //使用自定义注解来使用pointcut
        【导包】spring-context、spring-test、junit、lombok、aspectjweaver
        【application.xml】
            打开注解开关：<context:component-scan base-package="com.bupt"/>
                        <aop:aspectj-autoproxy/>
        【业务代码】UserService、UserServiceImpl
            //sayHello()方法中增加一条语句：Thread.sleep(5000)
        【自定义注解CountTime】
            //@interface
            //@Retention(RetentionPolicy.RUNTIME)  //这个自定义注解在程序运行时生效
              @Target(ElementType.METHOD)          //这个自定义注解加在方法上
        【编写切面类CustomAspect】
            //@Component、@Aspect
            //@Pointcut注解中不再写切入点表达式，而是自定义注解。//注解出现在哪里，哪里就被增强。
                  @Pointcut("annotation(com.bupt.anno.CountTime)")
                  public void mypointcut()
            //Aspect的通知方法这里也使用注解的方式，同demo2。
                  业务逻辑：使用around方法计算切入点方法的执行时间。
        【将自定义注解加在需要增强的方法上】
            //此处将@CountTime注解加在UserServiceImpl类的sayHello()方法上，sayHi()方法不加（作为对比）。
        【测试类】AspectjAnnotationTest
            @RunWith(SpringJUnit4ClassRunner.class)
            @ContextConfiguration("classpath:application.xml")
---------------------------------------------------------------------------------------------------------------------------------------------------------------
【Spring04-Tx】
---------------------------------------------------------------------------------------------------------------------------------------------------------------
【SpringMVC01】
---------------------------------------------------------------------------------------------------------------------------------------------------------------
【SpringMVC02】
---------------------------------------------------------------------------------------------------------------------------------------------------------------
【SpringMVC03】
---------------------------------------------------------------------------------------------------------------------------------------------------------------
【SpringMVC04】
---------------------------------------------------------------------------------------------------------------------------------------------------------------
【Mybatis01】
---------------------------------------------------------------------------------------------------------------------------------------------------------------
【Mybatis02】
---------------------------------------------------------------------------------------------------------------------------------------------------------------
【Mybatis03】
---------------------------------------------------------------------------------------------------------------------------------------------------------------
【Mybatis04】
---------------------------------------------------------------------------------------------------------------------------------------------------------------
【Mybatis05】
---------------------------------------------------------------------------------------------------------------------------------------------------------------


